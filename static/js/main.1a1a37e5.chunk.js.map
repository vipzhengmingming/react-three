{"version":3,"sources":["components/Points.ts","components/Earth3D.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Points","domID","app","document","getElementById","width","offsetWidth","height","offsetHeight","scene","THREE","stats","Stats","showPanel","appendChild","dom","group","add","camera","position","x","y","z","lookAt","mesh","mesh2","render","antialias","alpha","setPixelRatio","window","devicePixelRatio","setClearColor","setSize","domElement","Orbitcontrols","addEventListener","e","removeAttribute","spriteGroup","mixer","clock","mouse","raycaster","light","set","pointLight","spotLight","castShadow","shadow","mapSize","near","far","fov","spotLightHelper","initLight","material","color","linewidth","vertexmaterial","size","geometry","vertices","Float32Array","attribue","attributes","colors","normals","normal","geometry2","pointsArray2","push","setFromPoints","initObject","event","preventDefault","clientX","clientY","FBXLoader","load","obj","translateY","console","log","animations","clipAction","play","animate","requestAnimationFrame","children","forEach","sprite","update","getDelta","updateMatrixWorld","setFromCamera","intersects","intersectObjects","length","i","object","initRaycaster","Earth3D","useEffect","id","style","components","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","props","container","ReactDOM","querySelector","bootstrap","a","mount","unmount","unmountComponentAtNode","__POWERED_BY_QIANKUN__"],"mappings":"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","file":"static/js/main.1a1a37e5.chunk.js","sourcesContent":["import Orbitcontrols from \"three-orbitcontrols\";\nimport Stats from \"stats.js\";\n// import TWEEN from \"@tweenjs/tween.js\";\nimport * as THREE from \"three\";\n\n// import { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\n\n// import { STLLoader } from \"three/examples/jsm/loaders/STLLoader\";\n\n// import { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\";\n\n// import { MTLLoader } from \"three/examples/jsm/loaders/MTLLoader\";\n\nimport { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader\";\n// import GLTFLoader from \"three-gltf-loader\";\nclass Points {\n  constructor(domID: string) {\n    /********************************************************/\n    var app = document.getElementById(domID);\n    const width = app?.offsetWidth ?? 0;\n    const height = app?.offsetHeight ?? 0;\n    // 3个基础概念：场景（scene）、相机（camera）和渲染器（renderer）。\n    // == 场景是一个载体，容器，所有的一切都运行在这个容器里面（存放着所有渲染的物体和使用的光源）\n    // 创建场景\n    const scene = new THREE.Scene();\n\n    // 渲染性能性能监控器，查看Threejs渲染帧率FPS\n    var stats = new Stats();\n    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom\n    (app as Element).appendChild(stats.dom);\n    // 创建Group\n    const group = new THREE.Group();\n    scene.add(group);\n\n    // let canvas: any;\n\n    // function changeCanvas() {\n    //   canvas = document.createElement(\"canvas\");\n    //   canvas.width = width;\n    //   canvas.height = height;\n    //   (app as Element).appendChild(canvas);\n    //   const ctx = canvas.getContext(\"2d\");\n    //   ctx.font = \"16pt Arial\";\n    //   ctx.fillStyle = \"orange\";\n    //   ctx.fillRect(0, 0, canvas.width, canvas.height);\n    //   ctx.fillStyle = \"white\";\n    //   ctx.fillRect(10, 10, canvas.width - 20, canvas.height - 20);\n    //   ctx.fillStyle = \"black\";\n    //   ctx.textAlign = \"center\";\n    //   ctx.textBaseline = \"middle\";\n    //   for (let i = 0; i < canvas.width; i += 10) ctx.fillText(\"踏得网\", i, i);\n    // }\n    //创建相机\n    // ===相机 camera 的作用是定义可视域，相当于我们的双眼，生产一个个快照，最为常用的是 PerspectiveCamera 透视摄像机，\n    // 其他还有 ArrayCamera 阵列摄像机（包含多个子摄像机，通过这一组子摄像机渲染出实际效果，适用于 VR 场景），\n    // CubeCamera 立方摄像机（创建六个 PerspectiveCamera（透视摄像机），适用于镜面场景），StereoCamera 立体相机\n    //（双透视摄像机适用于 3D 影片、视差效果）。相机主要分为两类正投影相机和透视相机，正投影相机的话，\n    // 所有方块渲染出来的尺寸都一样； 对象和相机之间的距离不会影响渲染结果，而透视相机接近真实世界，看物体会产生远近高低各不同\n    const camera = new THREE.PerspectiveCamera(90, width / height, 1, 10000); //PerspectiveCamera 透视摄像机--模拟人眼的视觉，根据物体距离摄像机的距离，近大远小\n    camera.position.x = 0;\n    camera.position.y = 0;\n    camera.position.z = 100;\n    camera.lookAt(scene.position);\n\n    // 渲染\n    // =渲染器 renderer 则负责用如何渲染出图像，是使用 WeBGL 还是 Canvas，类似于 react 中 render，产生实际的页面效果\n    const render = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: true, //设置canvas为背景透明\n    });\n    render.setPixelRatio(window.devicePixelRatio);\n    render.setClearColor(\"black\"); // 环境背景色\n    render.setSize(width as number, height as number);\n    (app as Element).appendChild(render.domElement);\n\n    //增加监控的信息状态\n    // const stats = new Stats();\n    // container.appendChild( stats.dom );\n    let mesh: any;\n    let mesh2: any;\n    function initObject() {\n      // 定义一种线条的材质\n      const material = new THREE.LineBasicMaterial({\n        color: \"red\",\n        linewidth: 10,\n      });\n      // 面的材质\n      // var mshBasicMaterial = new THREE.MeshBasicMaterial({\n      //   color: 0x0000ff, //三角面颜色\n      //   side: THREE.DoubleSide, //两面可见\n      // });\n      //材质对象\n      var vertexmaterial = new THREE.PointsMaterial({\n        // 使用顶点颜色数据渲染模型，不需要再定义color属性\n        // color: 0xff0000,\n        size: 10.0, //点对象像素尺寸\n      });\n      //这里用这个构造\n      const geometry = new THREE.BufferGeometry();\n      var vertices = new Float32Array([\n        0,\n        0,\n        0, //顶点1坐标\n        50,\n        0,\n        0, //顶点2坐标\n        0,\n        50,\n        0, //顶点3坐标\n        0,\n        0,\n        0, //顶点4坐标\n        0,\n        0,\n        100, //顶点5坐标\n        50,\n        0,\n        0, //顶点6坐标\n      ]);\n      // 创建属性缓冲区对象\n      var attribue = new THREE.BufferAttribute(vertices, 3);\n      // 设置几何体attributes属性的位置属性\n      geometry.attributes.position = attribue;\n      var colors = new Float32Array([\n        1,\n        0,\n        0, //顶点1颜色\n        0,\n        1,\n        0, //顶点2颜色\n        0,\n        0,\n        1, //顶点3颜色\n\n        1,\n        1,\n        0, //顶点4颜色\n        0,\n        1,\n        1, //顶点5颜色\n        1,\n        0,\n        1, //顶点6颜色\n      ]);\n      // 设置几何体attributes属性的颜色color属性\n      geometry.attributes.color = new THREE.BufferAttribute(colors, 3);\n      var normals = new Float32Array([\n        0,\n        0,\n        1, //顶点1法向量\n        0,\n        0,\n        1, //顶点2法向量\n        0,\n        0,\n        1, //顶点3法向量\n\n        0,\n        1,\n        0, //顶点4法向量\n        0,\n        1,\n        0, //顶点5法向量\n        0,\n        1,\n        0, //顶点6法向量\n      ]);\n      // 设置几何体attributes属性的位置normal属性\n      geometry.attributes.normal = new THREE.BufferAttribute(normals, 3);\n      //下述基本一样\n      // mesh = new THREE.Line(geometry, [mshBasicMaterial, material]);\n      mesh = new THREE.Mesh(geometry, vertexmaterial);\n      mesh.position.set(0, 0, 10);\n      scene.add(mesh);\n\n      const geometry2 = new THREE.BufferGeometry();\n      const pointsArray2 = [];\n      pointsArray2.push(new THREE.Vector3(0, 0, 20));\n      pointsArray2.push(new THREE.Vector3(20, 0, 20));\n      pointsArray2.push(new THREE.Vector3(20, 20, 20));\n      pointsArray2.push(new THREE.Vector3(0, 20, 20));\n      pointsArray2.push(new THREE.Vector3(0, 0, 20));\n      geometry2.setFromPoints(pointsArray2);\n      //下述基本一样\n      mesh2 = new THREE.Line(geometry2, material);\n      mesh.position.set(20, 0, 0);\n      scene.add(mesh2);\n    }\n    // function initTween() {\n    //   new TWEEN.Tween(mesh.rotation)\n    //     .to({ y: 360 }, 3000)\n    //     .repeat(Infinity)\n    //     .start();\n    //   new TWEEN.Tween(mesh2.rotation)\n    //     .to({ y: 360 }, 3000)\n    //     .repeat(Infinity)\n    //     .start();\n    // }\n\n    // function initCubeGeometry() {\n    //   var planeGeometry2 = new THREE.PlaneGeometry(500, 500, 1, 1);\n    //   // 漫反射 MeshLambertMaterial  镜面反射 MeshPhongMaterial\n    //   var material = new THREE.MeshLambertMaterial();\n    //   material.side = THREE.DoubleSide;\n    //   var planeGeometryMesh = new THREE.Mesh(planeGeometry2, material);\n    //   // planeGeometryMesh.rotateX(90);\n    //   // scene.add(planeGeometryMesh);\n    //   // 几何体位置起点全部在物体的中心\n    //   var geometry = new THREE.CylinderGeometry(5, 5, 20, 32);\n    //   // 漫反射 MeshLambertMaterial  镜面反射 MeshPhongMaterial\n    //   var material = new THREE.MeshLambertMaterial({ color: 0xffffff }); // 我们使用了兰伯特材质，并将这种材质赋予了黑色\n    //   var cylinder = new THREE.Mesh(geometry, material);\n    //   var axesHelper = new THREE.AxesHelper(50);\n    //   cylinder.add(axesHelper);\n    //   cylinder.rotateZ(45);\n    //   cylinder.translateX(100);\n    //   group.add(cylinder);\n    //   // 创建几何体和材质----Mesh 网格, 使用canvas 当作材质\n    //   // var texture1 = new THREE.Texture(canvas);\n    //   // var geometry2 = new THREE.BoxBufferGeometry(20, 20, 20);\n    //   // var material2 = new THREE.MeshBasicMaterial({ map: texture1 });\n    //   // // 如果更改了图像，画布，视频和数据纹理，则需要设置以下标志：\n    //   // texture1.needsUpdate = true;\n    //   // var mesh3 = new THREE.Mesh(geometry2, material2);\n    //   // mesh3.position.set(0, 0, 10);\n    //   // scene.add(mesh3);\n\n    //   // var textureLoader = new THREE.TextureLoader(); // 纹理加载器\n    //   // var texture = textureLoader.load(\"/assets/gis.png\"); // 加载图片，返回Texture对象\n    //   // var planeGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);\n    //   // var material3 = new THREE.MeshBasicMaterial({ map: texture });\n    //   // material3.side = THREE.DoubleSide; // 为什么我的物体的一部分是不可见的？\n    //   // var mesh = new THREE.Mesh(planeGeometry, material3);\n    //   // scene.add(mesh);\n\n    //   // 立方几何体\n    //   var boxGeometry = new THREE.BoxGeometry(20, 20, 20);\n    //   const materialArr = [];\n    //   for (var i = 0; i < boxGeometry.groups.length; i++) {\n    //     var hex = Math.random() * 0xffffff;\n    //     var material4 = new THREE.MeshBasicMaterial({\n    //       color: new THREE.Color(hex),\n    //       opacity: 0.5,\n    //       transparent: true,\n    //     });\n    //     materialArr.push(material4);\n    //   }\n    //   var mesh4 = new THREE.Mesh(boxGeometry, materialArr);\n    //   mesh4.name = \"我是最帅的\";\n    //   // mesh4.position.set(50, 10, 20);\n    //   group.add(mesh4);\n    //   // group.translateY(20);\n    //   console.log(\"查看group的子对象\", scene.children);\n    // }\n\n    // 材质Material\n    // const showMaterial = () => {\n    //   var geometry = new THREE.SphereGeometry(100, 25, 25); //创建一个球体几何对象\n    //   // 创建一个点材质对象\n    //   var material = new THREE.PointsMaterial({\n    //     color: 0x0000ff, //颜色\n    //     size: 3, //点渲染尺寸\n    //   });\n    //   // 直线基础材质对象\n    //   var material2 = new THREE.LineBasicMaterial({\n    //     color: 0x0000ff,\n    //   });\n\n    //   var point = new THREE.Points(geometry, material);\n    //   scene.add(point); //网格模型添加到场景中\n    //   var line = new THREE.Line(geometry, material2); //线模型对象\n    //   scene.add(line); //网格模型添加到场景中\n    // };\n    // 相机作为Orbitcontrols的参数，支持鼠标交互\n    const controls = new Orbitcontrols(camera, render.domElement);\n    controls.addEventListener(\"change\", (e: Event) => {\n      //  render.render(scene, camera);\n    }); //监听鼠标、键盘事件\n    render.domElement.removeAttribute(\"tabindex\"); //去除鼠标控件使用时的白色边框\n    function initLight() {\n      // 平行光\n      const light = new THREE.DirectionalLight(0xffffff);\n      light.position.set(100, 100, 200);\n      scene.add(light);\n      // // 环境光\n      // const light2 = new THREE.AmbientLight(0xff0000);\n      // light2.position.set(100, 100, 200);\n      // scene.add(light2);\n      // 点光源\n      const pointLight = new THREE.PointLight(0xff0000, 1, 40);\n      pointLight.position.set(10, 10, 10);\n      scene.add(pointLight);\n      //  光源的辅助\n      // var spotLightHelper = new THREE.PointLightHelper(pointLight);\n      // scene.add(spotLightHelper);\n\n      const spotLight = new THREE.SpotLight(0xffff00);\n      spotLight.position.set(100, 1000, 100);\n      scene.add(spotLight);\n      spotLight.castShadow = true;\n\n      spotLight.shadow.mapSize.width = 1024;\n      spotLight.shadow.mapSize.height = 1024;\n\n      spotLight.shadow.camera.near = 500;\n      spotLight.shadow.camera.far = 4000;\n      spotLight.shadow.camera.fov = 30;\n      var spotLightHelper = new THREE.SpotLightHelper(spotLight);\n      scene.add(spotLightHelper);\n    }\n    //添加光源:环境光和点光源\n    // let ambi = new THREE.AmbientLight(0xffffff); //环境光\n    // scene.add(ambi);\n    // let directionalLight = new THREE.DirectionalLight(0xffffff, 1); //点光源\n    // scene.add(directionalLight);\n    // const spotLight = new THREE.SpotLight(0xffff00, 1.0, 0, 75);\n    // scene.add(spotLight);\n    // 世界坐标系\n    // const initWorldPosition = () => {\n    //   var geometry = new THREE.BoxGeometry(20, 20, 20);\n    //   var material = new THREE.MeshBasicMaterial({\n    //     color: 0x0000ff,\n    //   });\n    //   var mesh = new THREE.Mesh(geometry, material);\n    //   // mesh的本地坐标设置为(50, 0, 0)\n    //   mesh.position.set(50, 0, 0);\n    //   var group = new THREE.Group();\n    //   // group本地坐标设置和mesh一样设置为(50, 0, 0)\n    //   // mesh父对象设置position会影响得到mesh的世界坐标\n    //   group.position.set(50, 0, 0);\n    //   group.add(mesh);\n    //   scene.add(group);\n\n    //   // .position属性获得本地坐标\n    //   console.log(\"本地坐标\", mesh.position);\n\n    //   // getWorldPosition()方法获得世界坐标\n    //   //该语句默认在threejs渲染的过程中执行,如果渲染之前想获得世界矩阵属性、世界位置属性等属性，需要通过代码更新\n    //   scene.updateMatrixWorld(true);\n    //   var worldPosition = new THREE.Vector3();\n    //   mesh.getWorldPosition(worldPosition);\n    //   console.log(\"世界坐标\", worldPosition);\n    // };\n    var spriteGroup = new THREE.Group();\n    scene.add(spriteGroup);\n    // 精灵模型Sprite---下雨系统\n    // const initSprite = () => {\n    //   var texture = new THREE.TextureLoader().load(\"/assets/snowflake2.png\");\n    //   // 创建精灵材质对象SpriteMaterial\n    //   // var spriteMaterial = new THREE.SpriteMaterial({\n    //   //   color: 0xff00ff, //设置精灵矩形区域颜色\n    //   //   rotation: Math.PI / 3, //旋转精灵对象45度，弧度值\n    //   //   map: texture, //设置精灵纹理贴图\n    //   // });\n    //   // // 创建精灵模型对象，不需要几何体geometry参数\n    //   // var sprite = new THREE.Sprite(spriteMaterial);\n    //   // scene.add(sprite);\n    //   // // 控制精灵大小，比如可视化中精灵大小表征数据大小\n    //   // sprite.scale.set(10, 10, 1); //// 只需要设置x、y两个分量就可以\n    //   for (let i = 0; i < 400; i++) {\n    //     var spriteMaterial = new THREE.SpriteMaterial({\n    //       map: texture, //设置精灵纹理贴图\n    //     });\n    //     // 创建精灵模型对象\n    //     var sprite = new THREE.Sprite(spriteMaterial);\n    //     spriteGroup.add(sprite);\n    //     // 控制精灵大小,\n    //     sprite.scale.set(8, 10, 1); //// 只需要设置x、y两个分量就可以\n    //     var k1 = Math.random() - 0.5;\n    //     var k2 = Math.random() - 0.5;\n    //     var k3 = Math.random() - 0.5;\n    //     // 设置精灵模型位置，在整个空间上上随机分布\n    //     sprite.position.set(200 * k1, 200 * k3, 200 * k2);\n    //   }\n    // };\n\n    // STLLoader\n    // 辅助三维坐标系AxisHelper\n    // const initAxesHelper = () => {\n    //   // 辅助坐标系  参数250表示坐标系大小，可以根据场景大小去设置\n    //   var axesHelper = new THREE.AxesHelper(50);\n    //   scene.add(axesHelper);\n    // };\n    /*============模型加载==============*/\n\n    // 记载模型\n    // const getGLTFmodel = () => {\n    //   //  哪一种三维物体格式能够得到最好地支持？\n    //   // 推荐使用glTF（gl传输格式）来对三维物体进行导入和导出，由于glTF这种格式专注于在程序运行时呈现三维物体，\n    //   // 因此它的传输效率非常高，且加载速度非常快\n    //   const loader = new GLTFLoader();\n    //   loader.load(\n    //     \"/ftm/scene.gltf\",\n    //     (gltf) => {\n    //       // called when the resource is loaded\n    //       scene.add(gltf.scene);\n    //     },\n    //     (xhr) => {\n    //       // called while loading is progressing\n    //       console.log(`${(xhr.loaded / xhr.total) * 100}% loaded`);\n    //     },\n    //     (error) => {\n    //       // called when loading has errors\n    //       console.error(\"An error happened\", error);\n    //     }\n    //   );\n    // };\n\n    // 1-.stl格式模型加载----相当于几何体\n    // const initSTLLoader = () => {\n    //   var loader = new STLLoader();\n    //   // 立方体默认尺寸长宽高各200\n    //   loader.load(\n    //     \"/threejs/examples/models/stl/ascii/slotted_disk.stl\",\n    //     function (geometry: any) {\n    //       // 控制台查看加载放回的threejs对象结构\n    //       console.log(geometry);\n    //       // 查看顶点数，一个立方体6个矩形面，每个矩形面至少2个三角面，每个三角面3个顶点，\n    //       // 如果没有索引index复用顶点，就是说一个立方体至少36个顶点\n    //       console.log(geometry.attributes.position.count);\n    //       // 缩放几何体\n    //       // geometry.scale(0.5,0.5,0.5);\n    //       // 几何体居中\n    //       // geometry.center();\n    //       // 平移立方体\n    //       // geometry.translate(-50,-50,-50);\n    //       var material = new THREE.MeshBasicMaterial({\n    //         color: \"red\",\n    //       }); //材质对象Material\n    //       var mesh = new THREE.Points(geometry, material); //网格模型对象Mesh\n    //       scene.add(mesh); //网格模型添加到场景中\n    //     }\n    //   );\n    // };\n\n    // 2-.obj 模型加载  obj + mtl\n    // const initOBJandMTL = () => {\n    //   let OBJLoader2 = new OBJLoader(); //obj加载器\n    //   let MTLLoader2 = new MTLLoader(); //材质文件加载器\n    //   MTLLoader2.load(\n    //     \"/threejs/examples/models/obj/male02/male02_dds.mtl\",\n    //     function (materials: any) {\n    //       // 返回一个包含材质的对象MaterialCreator\n    //       console.log(materials);\n    //       //obj的模型会和MaterialCreator包含的材质对应起来\n    //       OBJLoader2.setMaterials(materials);\n    //       OBJLoader2.load(\n    //         \"/threejs/examples/models/obj/male02/male02.obj\",\n    //         function (obj: any) {\n    //           console.log(obj);\n    //           //  obj.scale.set(2, 2, 2); //放大obj组对象\n    //           scene.add(obj); //返回的组对象插入场景中\n    //         }\n    //       );\n    //     }\n    //   );\n    // };\n\n    let mixer: any = null; //声明一个混合器变量\n    // 3- pbx模型帧动画\n    const initFBXLoader = () => {\n      var loader = new FBXLoader(); //创建一个FBX加载器\n      loader.load(\n        \"/threejs/examples/models/fbx/Samba%20Dancing.fbx\",\n        function (obj) {\n          // console.log(obj);//查看加载后返回的模型对象\n          scene.add(obj);\n          // 适当平移fbx模型位置\n          obj.translateY(-80);\n\n          // obj作为参数创建一个混合器，解析播放obj及其子对象包含的动画数据\n          mixer = new THREE.AnimationMixer(obj);\n          // 查看动画数据\n          console.log(obj.animations);\n          // obj.animations[0]：获得剪辑对象clip\n          var AnimationAction = mixer.clipAction(obj.animations[0]);\n          // AnimationAction.timeScale = 1; //默认1，可以调节播放速度\n          // AnimationAction.loop = THREE.LoopOnce; //不循环播放\n          // AnimationAction.clampWhenFinished=true;//暂停在最后一帧播放的状态\n          AnimationAction.play(); //播放动画\n        }\n      );\n    };\n\n    // 参照物 网格\n    // const initGrid = () => {\n    //   // 网格的边长是1000，每个小网格的边长是50\n    //   var helper = new THREE.GridHelper(500, 50, 0x0000ff, 0x808080);\n    //   scene.add(helper);\n    // };\n    // 窗口大小响应\n    // function onWindowResize() {\n    //   camera.aspect = window.innerWidth / window.innerHeight;\n    //   camera.updateProjectionMatrix();\n    //   render.setSize(window.innerWidth, window.innerHeight);\n    // }\n    // 渲染函数\n    function spriteGroupRender() {\n      // 每次渲染遍历雨滴群组，刷新频率30~60FPS，两帧时间间隔16.67ms~33.33ms\n      // 每次渲染都会更新雨滴的位置，进而产生动画效果\n      spriteGroup.children.forEach((sprite) => {\n        // 雨滴的y坐标每次减1\n        sprite.position.y -= 1;\n        if (sprite.position.y < -200) {\n          // 如果雨滴落到地面，重置y，从新下落\n          sprite.position.y = 200;\n        }\n      });\n    }\n\n    var clock = new THREE.Clock();\n    // 渲染函数\n    function renderClock() {\n      if (mixer !== null) {\n        //clock.getDelta()方法获得两帧的时间间隔\n        // 更新混合器相关的时间\n        mixer.update(clock.getDelta());\n      }\n    }\n    let mouse: any = null;\n    /*=========事件交互========*/\n    const onDocumentMouseMove = (event: MouseEvent) => {\n      event.preventDefault();\n      mouse = new THREE.Vector2();\n      mouse.x = (event.clientX / width) * 2 - 1;\n      mouse.y = -(event.clientY / height) * 2 + 1;\n    };\n    const raycaster: any = new THREE.Raycaster();\n    const initRaycaster = () => {\n      if (!mouse) return;\n      camera.updateMatrixWorld();\n      raycaster.setFromCamera(mouse, camera);\n\n      const intersects = raycaster.intersectObjects(scene.children, false);\n\n      if (intersects.length > 0) {\n        for (var i = 0; i < intersects.length; i++) {\n          intersects[i].object.material.color.set(0xff0000);\n        }\n\n        // const targetDistance: number = intersects[0].distance;\n        // camera.setFocalLength(targetDistance);\n        // INTERSECTED = intersects?.[0]?.object;\n        // INTERSECTED.material.color = new THREE.Color(0xff0000);\n      }\n      mouse = null;\n    };\n    //渲染循环\n    var animate = function () {\n      requestAnimationFrame(animate);\n      spriteGroupRender();\n      renderClock();\n      //  弧度计算公式 度＝弧度×180°/π\n      // 将上面的弧度变为0.01,计算的结果是0.57，也就是每个帧循环将旋转0.57度。\n      //  initTween();\n      // mesh2.rotation.y -= 0.002; //整体转动\n      // camera.rotation.y -= 0.002; //整体平移\n      // texture.needsUpdate = true;\n      initRaycaster();\n      render.render(scene, camera);\n      stats.update();\n      // TWEEN.update();\n    };\n    // initAxesHelper();\n    // initGrid();\n    // showMaterial();\n    // changeCanvas();\n    initLight();\n    initObject();\n    // initWorldPosition();\n    // initCubeGeometry();\n    // getGLTFmodel();\n    // initTween();\n    // initSprite();\n    // initSTLLoader();\n    // initOBJandMTL();\n    app?.addEventListener(\"click\", onDocumentMouseMove);\n    initFBXLoader();\n    animate();\n  }\n}\n\nexport default Points;\n","import React, { useEffect } from \"react\";\n// import Gis from \"./gis\";\n// import { data } from \"./data\";\n// import ThreeGis from \"./three-gis\";\nimport Points from \"./Points\";\n// import WebVR from \"./WebVR\";\ntype Earth3DProps = {};\nconst Earth3D: React.FC<Earth3DProps> = () => {\n  useEffect(() => {\n    // const gis = new Gis(\"globeArea\");\n    // gis.addData(data);\n    // new ThreeGis(\"globeArea\");\n    new Points(\"globeArea\");\n    // new WebVR(\"globeArea\");\n  }, []);\n  return <div id=\"globeArea\" style={{ width: \"500px\", height: \"500px\" }}></div>;\n};\n\nexport default Earth3D;\n","import React from \"react\";\nimport Earth3D from \"./components/Earth3D\";\nimport \"./App.css\";\n\nconst components = { Earth3D };\nfunction App() {\n  return (\n    <div className=\"App\">\n      <components.Earth3D />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\n// ReactDOM.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>,\n//   document.getElementById(\"root\")\n// );\n\nfunction render(props: { container?: any }) {\n  const { container } = props;\n  ReactDOM.render(\n    <App />,\n    container\n      ? container.querySelector(\"#root\")\n      : document.querySelector(\"#root\")\n  );\n}\n\nif (!(window as any).__POWERED_BY_QIANKUN__) {\n  render({});\n}\n\nexport async function bootstrap() {\n  console.log(\"[react16] react app bootstraped\");\n}\n\nexport async function mount(props: any) {\n  console.log(\"[react16] props from main framework\", props);\n  render(props);\n}\n\nexport async function unmount(props: { container: any }) {\n  const { container } = props;\n  ReactDOM.unmountComponentAtNode(\n    container\n      ? container.querySelector(\"#root\")\n      : document.querySelector(\"#root\")\n  );\n}\n\nreportWebVitals();\n"],"sourceRoot":""}